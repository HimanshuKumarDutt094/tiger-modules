#!/usr/bin/env node
import { spawnSync } from "child_process";
import fs from "fs";
import path from "path";
import fg from "fast-glob";
import { generateGlobalDts } from "./generate-types";

async function copyDir(src: string, dest: string) {
  // Check if source exists
  if (!fs.existsSync(src)) {
    console.log(`source directory ${src} does not exist, skipping copy`);
    return;
  }

  // Check if source is a directory
  const srcStat = await fs.promises.stat(src);
  if (!srcStat.isDirectory()) {
    console.log(`source ${src} is not a directory, skipping copy`);
    return;
  }

  console.log(`copying ${src} -> ${dest}`);

  // prefer fs.cp when available
  // @ts-ignore
  if (fs.cp) {
    await fs.promises.mkdir(dest, { recursive: true });
    // @ts-ignore
    return fs.promises.cp(src, dest, { recursive: true, errorOnExist: false });
  }
  // fallback: simple recursive copy
  const entries = await fs.promises.readdir(src, { withFileTypes: true });
  await fs.promises.mkdir(dest, { recursive: true });
  for (const ent of entries) {
    const srcPath = path.join(src, ent.name);
    const dstPath = path.join(dest, ent.name);
    if (ent.isDirectory()) {
      await copyDir(srcPath, dstPath);
    } else if (ent.isFile()) {
      await fs.promises.copyFile(srcPath, dstPath);
      console.log(`  copied file: ${ent.name}`);
    } else if (ent.isSymbolicLink()) {
      // Handle symlinks by reading and recreating them
      const linkTarget = await fs.promises.readlink(srcPath);
      await fs.promises.symlink(linkTarget, dstPath);
      console.log(`  copied symlink: ${ent.name}`);
    }
  }
}

function runTsdown(cwd: string) {
  console.log("running tsdown in", cwd);
  const res = spawnSync("npx", ["tsdown"], {
    cwd,
    stdio: "inherit",
    shell: true,
  });
  if (res.error || res.status !== 0) {
    throw new Error("tsdown failed");
  }
  console.log("tsdown compilation completed successfully");
  
  // Verify config.js was compiled
  const configJs = path.join(cwd, "dist", "config.js");
  if (fs.existsSync(configJs)) {
    console.log("✓ module.config.ts compiled to dist/config.js");
  } else {
    console.warn("⚠ dist/config.js not found - ensure module.config.ts is in tsdown entry points");
  }
}

async function writeDistInstall(distDir: string) {
  const out = path.join(distDir, "install.js");
  const content = `import install from 'lynxjs-module/install';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const moduleDir = __dirname;

console.log("Starting lynx module installer...");
console.log("Module directory:", moduleDir);
install({ moduleDir }).catch((err) => {
  console.error('lynx module installer failed:', err);
  process.exit(1);
});
`;
  await fs.promises.writeFile(out, content, "utf8");
  console.log("wrote", out);
}

async function copyDeclarationFiles(moduleDir: string, distDir: string) {
  console.log("searching for TypeScript declaration files...");
  
  // Find all .d.ts files in the module root (generated by codegen)
  const dtsFiles = await fg(["*.d.ts", "!node_modules/**"], {
    cwd: moduleDir,
    absolute: true,
    onlyFiles: true,
  });

  if (dtsFiles.length === 0) {
    console.log("no declaration files found in module root");
    return;
  }

  console.log(`found ${dtsFiles.length} declaration file(s)`);
  
  for (const srcFile of dtsFiles) {
    const fileName = path.basename(srcFile);
    const dstFile = path.join(distDir, "global.d.ts");
    await fs.promises.copyFile(srcFile, dstFile);
    console.log(`  copied: ${fileName} -> dist/${fileName}`);
  }
}

async function writeDistPackageJson(moduleDir: string, distDir: string) {
  const pkgPath = path.join(moduleDir, "package.json");
  const pkg = JSON.parse(await fs.promises.readFile(pkgPath, "utf8"));
  
  // Ensure postinstall runs dist/install.js
  pkg.scripts = pkg.scripts || {};
  pkg.scripts.postinstall = "node ./install.js";
  
  // Make sure files include what we need
  pkg.files = Array.from(
    new Set([
      ...(pkg.files || []),
      "android",
      "ios",
      "*.js",
      "*.d.ts",
      "config.js",
      "install.js"
    ])
  );
  
  // Set correct paths for main/module/types
  pkg.main = "./index.js";
  pkg.module = "./index.js";
  pkg.types = "./index.d.ts";
  
  // Ensure proper exports map
  pkg.exports = pkg.exports || {};
  
  // Main entry point
  pkg.exports["."] = {
    types: "./index.d.ts",
    import: "./index.js",
    require: "./index.js",
  };
  
  // Config entry point
  pkg.exports["./config"] = {
    types: "./config.d.ts",
    import: "./config.js",
    require: "./config.js",
  };
  
  // Find and add module-specific type declarations
  const dtsFiles = await fg(["*.d.ts", "!index.d.ts", "!config.d.ts"], {
    cwd: distDir,
    onlyFiles: true,
  });
  
  for (const dtsFile of dtsFiles) {
    const baseName = path.basename(dtsFile, ".d.ts");
    const exportKey = `./types/${baseName}`;
    pkg.exports[exportKey] = {
      types: `./${dtsFile}`,
    };
  }
  
  // Keep package.json export
  pkg.exports["./package.json"] = "./package.json";
  
  const outPkg = path.join(distDir, "package.json");
  await fs.promises.writeFile(
    outPkg,
    JSON.stringify(pkg, null, 2) + "\n",
    "utf8"
  );
  console.log("wrote", outPkg);
  console.log("  main:", pkg.main);
  console.log("  types:", pkg.types);
  console.log("  files:", pkg.files);
  console.log("  exports:", Object.keys(pkg.exports).join(", "));
}

export default async function buildModule() {
  const moduleDir = process.cwd();
  const distDir = path.join(moduleDir, "dist");
  
  console.log("building module in", moduleDir);
  console.log("output directory:", distDir);
  
  // 1. run tsdown to compile TS -> dist (this clears dist first)
  runTsdown(moduleDir);
  
  // 2. Generate global.d.ts from TigerModule interface (after tsdown)
  try {
    generateGlobalDts(path.join(distDir, "global.d.ts"));
    console.log("✓ generated global.d.ts for LynxJS binding");
  } catch (err) {
    console.warn("⚠ global.d.ts generation failed:", err instanceof Error ? err.message : err);
  }

  // 3. copy android and ios into dist with enhanced error handling
  const androidSrc = path.join(moduleDir, "android");
  const iosSrc = path.join(moduleDir, "ios");
  
  try {
    await copyDir(androidSrc, path.join(distDir, "android"));
    console.log("✓ copied android -> dist/android");
  } catch (err) {
    console.warn("⚠ copy android failed:", err instanceof Error ? err.message : err);
  }
  
  try {
    await copyDir(iosSrc, path.join(distDir, "ios"));
    console.log("✓ copied ios -> dist/ios");
  } catch (err) {
    console.warn("⚠ copy ios failed:", err instanceof Error ? err.message : err);
  }

  // 4. copy any additional TypeScript declaration files to dist
  try {
    await copyDeclarationFiles(moduleDir, distDir);
    console.log("✓ copied declaration files to dist/");
  } catch (err) {
    console.warn("⚠ copy declaration files failed:", err instanceof Error ? err.message : err);
  }

  // 5. create dist/install.js that delegates to lynxjs-module install
  await writeDistInstall(distDir);

  // 6. write dist/package.json with postinstall
  await writeDistPackageJson(moduleDir, distDir);

  console.log("\n✅ build finished for", moduleDir);
}

// ES module safe entry check. In ESM `require` and `module` are undefined,
// so compare the resolved entry script path with this module's path.
if (typeof process !== "undefined") {
  try {
    const entry =
      process.argv && process.argv[1] ? path.resolve(process.argv[1]) : null;
    const here = path.resolve(new URL(import.meta.url).pathname);
    if (entry && entry === here) {
      buildModule().catch((err) => {
        console.error(err);
        process.exit(1);
      });
    }
  } catch (e) {
    // fallback: attempt to run
    // (if import.meta is not supported for some reason)
    // no-op
  }
}
