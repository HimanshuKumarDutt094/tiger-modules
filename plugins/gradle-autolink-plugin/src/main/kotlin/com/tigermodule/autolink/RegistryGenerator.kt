package com.tigermodule.autolink

import java.io.File

/**
 * Generates ExtensionRegistry.kt for Android
 */
class RegistryGenerator {
    
    private val validator = ConfigValidator()
    
    /**
     * Generates the ExtensionRegistry.kt file
     */
    fun generateAndroidRegistry(
        extensions: List<ExtensionPackage>,
        outputDir: File,
        packageName: String = "com.tigermodule.autolink.generated"
    ) {
        if (extensions.isEmpty()) {
            println("‚ÑπÔ∏è  No extensions to register, skipping registry generation")
            return
        }
        
        // Validate all extensions before generating
        try {
            extensions.forEach { ext ->
                validator.validateExtension(ext)
            }
        } catch (e: Exception) {
            throw Exception(
                "Cannot generate registry due to validation errors.\n" +
                "Fix the configuration errors above and try again.\n" +
                "Original error: ${e.message}"
            )
        }
        
        val registryCode = buildString {
            appendLine("package $packageName")
            appendLine()
            appendLine("import android.content.Context")
            appendLine("import android.app.Application")
            appendLine("import com.lynx.tasm.LynxEnv")
            appendLine("import com.lynx.tasm.behavior.Behavior")
            appendLine("import com.lynx.tasm.behavior.LynxContext")
            appendLine()
            
            // Import statements for discovered modules
            extensions.forEach { ext ->
                val androidConfig = ext.config.platforms.android ?: return@forEach
                
                if (ext.config.nativeModules.isNotEmpty()) {
                    appendLine("// Native Modules from ${ext.name}")
                    ext.config.nativeModules.forEach { moduleConfig ->
                        // Generate fully qualified import: packageName.className
                        appendLine("import ${androidConfig.packageName}.${moduleConfig.className}")
                    }
                }
                
                if (ext.config.elements.isNotEmpty()) {
                    appendLine("// Elements from ${ext.name}")
                    ext.config.elements.forEach { elementName ->
                        appendLine("import ${androidConfig.packageName}.${elementName}")
                    }
                }
                
                if (ext.config.services.isNotEmpty()) {
                    appendLine("// Services from ${ext.name}")
                    ext.config.services.forEach { serviceName ->
                        appendLine("import ${androidConfig.packageName}.${serviceName}")
                    }
                }
                
                appendLine()
            }
            
            appendLine("/**")
            appendLine(" * Auto-generated registry for TigerModule extensions")
            appendLine(" * Generated by TigerModule Autolink Gradle Plugin v${BuildConfig.VERSION}")
            appendLine(" * ")
            appendLine(" * This file is automatically generated. Do not edit manually.")
            appendLine(" * ")
            appendLine(" * Discovered extensions:")
            extensions.forEach { ext ->
                appendLine(" *   - ${ext.name}@${ext.version}")
            }
            appendLine(" */")
            appendLine("object ExtensionRegistry {")
            appendLine()
            appendLine("    /**")
            appendLine("     * Registers all discovered TigerModule extensions with the application")
            appendLine("     * Call this method in your Application.onCreate() or Activity.onCreate()")
            appendLine("     * ")
            appendLine("     * @param context Android application context")
            appendLine("     */")
            appendLine("    fun setupGlobal(context: Context) {")
            appendLine("        // Validate and cast context to Application if needed")
            appendLine("        val applicationContext = when (context) {")
            appendLine("            is android.app.Application -> context")
            appendLine("            else -> {")
            appendLine("                try {")
            appendLine("                    context.applicationContext as? android.app.Application")
            appendLine("                        ?: throw IllegalArgumentException(\"Context must be Application or provide Application context\")")
            appendLine("                } catch (e: Exception) {")
            appendLine("                    android.util.Log.e(\"ExtensionRegistry\", \"Failed to get Application context: \${e.message}\")")
            appendLine("                    throw IllegalArgumentException(\"Invalid context provided. Extensions requiring Application context will not work properly.\", e)")
            appendLine("                }")
            appendLine("            }")
            appendLine("        }")
            appendLine()
            
            // Check if any extensions require initialization
            val hasInitialization = extensions.any { ext ->
                ext.config.platforms.android?.initialization != null
            }
            
            if (hasInitialization) {
                appendLine("        // Register lifecycle callbacks for extensions that require them")
                extensions.forEach { ext ->
                    val androidConfig = ext.config.platforms.android ?: return@forEach
                    val initialization = androidConfig.initialization ?: return@forEach
                    
                    initialization.hooks.forEach { hook ->
                        if (hook.type == "lifecycle_callbacks" && hook.className != null) {
                            appendLine("        // Register lifecycle callbacks for ${ext.name}")
                            appendLine("        try {")
                            appendLine("            val ${hook.className.replaceFirstChar { it.lowercase() }}Instance = ${androidConfig.packageName}.${hook.className}()")
                            appendLine("            applicationContext.registerActivityLifecycleCallbacks(${hook.className.replaceFirstChar { it.lowercase() }}Instance)")
                            appendLine("            android.util.Log.d(\"ExtensionRegistry\", \"Registered lifecycle callbacks: ${hook.className}\")")
                            appendLine("        } catch (e: Exception) {")
                            appendLine("            android.util.Log.e(\"ExtensionRegistry\", \"Failed to register lifecycle callbacks ${hook.className}: \${e.message}\")")
                            appendLine("        }")
                        }
                    }
                }
                appendLine()
            }
            
            appendLine("        // Register native modules using LynxEnv.inst().registerModule()")
            
            val hasModules = extensions.any { it.config.nativeModules.isNotEmpty() }
            if (hasModules) {
                extensions.forEach { ext ->
                    val androidConfig = ext.config.platforms.android ?: return@forEach
                    ext.config.nativeModules.forEach { moduleConfig ->
                        appendLine("        // From ${ext.name}: ${androidConfig.packageName}.${moduleConfig.className}")
                        appendLine("        try {")
                        // Note: ::class.java syntax works for both Kotlin and Java classes
                        appendLine("            LynxEnv.inst().registerModule(\"${moduleConfig.name}\", ${moduleConfig.className}::class.java)")
                        appendLine("            android.util.Log.d(\"ExtensionRegistry\", \"Registered module: ${moduleConfig.name}\")")
                        appendLine("        } catch (e: Exception) {")
                        appendLine("            android.util.Log.e(\"ExtensionRegistry\", \"Failed to register module ${moduleConfig.name}: \${e.message}\")")
                        appendLine("        }")
                    }
                }
            } else {
                appendLine("        // No native modules to register")
            }
            
            appendLine()
            appendLine("        // Register custom elements using LynxEnv.inst().addBehavior()")
            
            val hasElements = extensions.any { it.config.elements.isNotEmpty() }
            if (hasElements) {
                extensions.forEach { ext ->
                    ext.config.elements.forEach { elementName ->
                        appendLine("        try {")
                        appendLine("            LynxEnv.inst().addBehavior(object : Behavior(\"${elementName}\") {")
                        appendLine("                override fun createUI(context: LynxContext): ${elementName} {")
                        appendLine("                    return ${elementName}(context)")
                        appendLine("                }")
                        appendLine("            })")
                        appendLine("            android.util.Log.d(\"ExtensionRegistry\", \"Registered element: ${elementName}\")")
                        appendLine("        } catch (e: Exception) {")
                        appendLine("            android.util.Log.e(\"ExtensionRegistry\", \"Failed to register element ${elementName}: \${e.message}\")")
                        appendLine("        }")
                    }
                }
            } else {
                appendLine("        // No custom elements to register")
            }
            
            appendLine()
            appendLine("        // Register services")
            
            val hasServices = extensions.any { it.config.services.isNotEmpty() }
            if (hasServices) {
                extensions.forEach { ext ->
                    ext.config.services.forEach { serviceName ->
                        appendLine("        // TODO: Service registration for ${serviceName}")
                        appendLine("        android.util.Log.d(\"ExtensionRegistry\", \"Service ${serviceName} needs manual registration\")")
                    }
                }
            } else {
                appendLine("        // No services to register")
            }
            
            appendLine("    }")
            appendLine("}")
        }
        
        // Ensure output directory exists
        outputDir.mkdirs()
        
        // Write registry file
        val registryFile = File(outputDir, "ExtensionRegistry.kt")
        registryFile.writeText(registryCode)
        
        println("‚úÖ Generated ExtensionRegistry.kt")
        println("   üìÅ ${registryFile.absolutePath}")
    }
}
